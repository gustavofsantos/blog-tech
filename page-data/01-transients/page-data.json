{"componentChunkName":"component---src-templates-blog-post-js","path":"/01-transients/","result":{"data":{"site":{"siteMetadata":{"title":"Blog do Gus"}},"markdownRemark":{"id":"87a83b21-278a-53b0-ad2a-6fff573e8169","excerpt":"Este é um assunto sobre Design Declarativo Funcional. Qual é o problema de uma função pura realizar mutações no seu estado interno desde que não seja exposto ao…","html":"<p>Este é um assunto sobre Design Declarativo Funcional.</p>\n<p>Qual é o problema de uma função pura realizar mutações no seu estado interno desde que não seja exposto ao mundo externo?</p>\n<h3>Funções Puras</h3>\n<p>Funções puras são funções que, para uma dada entrada, sempre vai produzir a mesma saída sem causar efeitos colaterais no sistema. O que é o sistema? O sistema é o contexto em que a função está sendo executada. Por exemplo:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">soma</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">a<span class=\"token punctuation\">,</span> b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">const</span> res <span class=\"token operator\">=</span> a <span class=\"token operator\">+</span> b\n\tconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">soma(</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>a<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">, </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>b<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">) = </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>res<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">return</span> res\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Embora <code class=\"language-text\">soma</code> seja uma função pura, ela causa um efeito colateral na saída padrão. Isso está longe do esperado para a função <code class=\"language-text\">soma</code>. É esperado que sejam somados dois valores e que o resultado seja retornado para o contexto que chamou esta função. Isso de fato acontece, porém mais coisas acontecem no contexto da função <code class=\"language-text\">soma</code>, por este motivo, esta função é considerada <strong>impura</strong>.</p>\n<h3>Reflexo da pureza</h3>\n<p>Em linguagens estritamente funcionais, não existe o conceito de mutabilidade. Um pedaço de memória uma vez criado, será constante até que seja coletado pelo coletor de lixo, caso a linguagem tenha suporte a coleta de lixo, ou que o programe chegue ao fim.</p>\n<p>Ou seja, abstrações como <em>loops</em> não existem.</p>\n<p>Porém nossos computadores não funcionam desta forma, nossos computadores convencionais modernos precisam de mutabilidade. Eles foram desenvolvidos usando conceitos de mutabilidade. A arquitetura que é usada hoje na construção dos computadores modernos é muito parecida com a arquitetura de Von Neumann.</p>\n<p>Então como é possível que linguagens puramente funcionais existam hoje? Porquê essas linguagens importam?</p>\n<blockquote>\n<p>Por tras de uma excelente linguagem, sempre existe um excelente compilador.</p>\n</blockquote>\n<p>Uma linguagem de programação realmente poderosa é nada se o compilador não for igualmente poderoso. Porém linguagens muito mal desenhadas podem ser muito poderosas se munidas de um ótimo compilador. Toda a suíte do V8 do Google Chrome está aí para provar o que estou dizendo.</p>\n<p>Linguagens puramente funcionais possuem otimizações a nível de geração de código de máquina. Por exemplo, em Haskell, o código abaixo é tão bem otimizado pelo compilador que, no final do processo, o código gerado é tão eficiente quando o código gerado pelo GCC ou Clang:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">fib</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Int</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Int</span>\n<span class=\"token hvariable\">fib</span> <span class=\"token number\">0</span> <span class=\"token hvariable\">_</span> <span class=\"token hvariable\">_</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n<span class=\"token hvariable\">fib</span> <span class=\"token number\">1</span> <span class=\"token hvariable\">_</span> <span class=\"token hvariable\">_</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n<span class=\"token hvariable\">fib</span> <span class=\"token hvariable\">x</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">fib</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">b</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token operator\">+</span><span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>O GHC transforma a chamada pura, recursiva, em um procedimento impuro que usa mutabilidade. O ponto que eu quero chegar é: qual é o problema se em algum momento um compilador ou uma biblioteca usar mutabilidade para melhoria de performance e esconder esses truques do restante do código?</p>\n<p>Rich Hickey já fez essa provocação muito tempo atrás. O próprio site do Clojure faz a seguinte provocação:</p>\n<blockquote>\n<p>If a tree falls in the woods, does it make a sound?</p>\n</blockquote>\n<blockquote>\n<p>If a pure function mutates some local data in order to produce an immutable return value, is that ok?</p>\n</blockquote>\n<p>Se você, programador JavaScript, por algum motivo precisar buscar um dado em um array, você escreveria uma função recursiva?</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">search</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">value<span class=\"token punctuation\">,</span> arr</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">.</span>length <span class=\"token operator\">===</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>head<span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span>tail<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>head <span class=\"token operator\">===</span> value<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token function\">search</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">,</span> tail<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>O código acima seria a sua primeira opção?</p>\n<p>Uma coisa precisamos entender: recursividade é ótima, conseguimos escrever funções extremamente consisas e claras. Conseguimos usar metodos de otimização muito bons, como programação dinâmica. Porém funções recursivas precisam de uma infraestrutura preparada tanto para suportar chamadas recursivas, quanto para otimizar chamadas recursivas. JavaScript não é esse tipo de linguagem.</p>\n<p>Se você é um profissional decente, você sabe que deve escrever código limpo. Então porquê não isolar um código que usa mutabilidade dentro de uma função <em>“pura”</em>?</p>\n<h3>Transientes</h3>\n<p>Se você chegou até aqui, já deve ter entendido onde eu quero chegar, talvez já tenha entendido o que valores transientes são.</p>\n<p>Mas caso não, veja essas duas funções:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">range1</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">start<span class=\"token punctuation\">,</span> end</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span>\n  start <span class=\"token operator\">===</span> end\n  <span class=\"token operator\">?</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n  <span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>start<span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span><span class=\"token function\">range</span><span class=\"token punctuation\">(</span>start <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> end<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span> </code></pre></div>\n<p>E</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">range2</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">start<span class=\"token punctuation\">,</span> end</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> arr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> start<span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> end<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> arr<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> arr<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Qual versão é pura? Qual é a versão mais eficiente?</p>\n<p>Usar transientes não é uma questão de pureza, é uma questão de eficiencia.</p>\n<p>Ah, a propósito, transientes no contexto de programação funcional é o ato de esconder mutabilidade atrás de uma interface pura. </p>","frontmatter":{"title":"Transientes","date":"May 20, 2020","description":"Essa é a descrição"}}},"pageContext":{"slug":"/01-transients/","previous":null,"next":null}}}